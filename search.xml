<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理第三章-存储系统</title>
      <link href="/2023/08/13/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2023/08/13/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="存储系统的基本概念"><a href="#存储系统的基本概念" class="headerlink" title="存储系统的基本概念"></a>存储系统的基本概念</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><table><thead><tr><th>外存</th><th>辅存</th><th>内存</th><th>高速缓冲存储器</th><th>寄存器</th><th>CPU</th></tr></thead><tbody><tr><td>磁带光盘</td><td>磁盘</td><td>主存</td><td>cache</td><td>寄存器</td><td>CPU</td></tr><tr><td>速度最慢</td><td>—&gt;</td><td>—&gt;</td><td>—-&gt;</td><td>—&gt;</td><td>速度最快</td></tr><tr><td>容量最大</td><td>—&gt;</td><td>—&gt;</td><td>—-&gt;</td><td>—&gt;</td><td>容量最小</td></tr><tr><td>价格最低</td><td>—&gt;</td><td>—&gt;</td><td>—-&gt;</td><td>—&gt;</td><td>价格最高</td></tr></tbody></table><div class="mermaid-wrap"><pre class="mermaid-src" hidden>   flowchart LRCPU--&gt;Cache--&gt;主存--&gt;辅存辅存--&gt;主存--&gt;Cache--&gt;CPU主存--&gt;CPUCPU--&gt;|Cache主存层|主存  </pre></div><blockquote><p>辅存中的数据要调入主存后才能被CPU访问<br>主存的读写速度跟不上CPU的处理速度，因此主存内容复制到cache中，由CPU直接访问，缓解速度矛盾。<br>主存–辅存，需要硬件和操作系统，利用页面置换算法。实现虚拟存储系统，解决了主存容量不足的问题。</p></blockquote><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><ul><li><p><strong>按层次分类</strong>：</p><ul><li>高速缓存（cache）</li><li>主存储器（主存，内存）</li><li>辅助存储器（辅存，外存）</li></ul></li><li><p><strong>按存储介质分类</strong>：</p><ul><li>半导体存储器（主存，cache）</li><li>磁表面存储器（磁带，磁盘）-以磁性材料为介质</li><li>光存储器（光盘，DVD）</li></ul></li><li><p><strong>按存取方式分类</strong>：</p><ul><li>随机存取存储器RAM：读写任一单元，所需的时间都相同，与物理位置无关。</li><li>顺序存取存储器SAM：读写存储单元的时间取决于物理位置。</li><li>直接存取存储器DAM：包含上述二者的特性，先选取信息所在的区域，再按顺序方式存取。同样，时间取决于物理位置。</li><li>相连存储器CAM：按照内容检索到存储位置进行读写。如“快表”。</li></ul></li><li><p><strong>按信息的可更改性分类</strong>：</p><ul><li>读写存储器</li><li>只读存储器ROM: 只读，不写。</li></ul></li><li><p><strong>按信息的可保存性分类</strong>：</p><ul><li>易失性存储器（主存，cache）：断电后，信息消失。</li><li>非易失性存储器（磁盘等）：断电后，信息保持。</li><li>破坏性读出（DRAM芯片）：信息读出后，原信息被破坏。</li><li>非破坏性读出（SRAM芯片、磁盘等）</li></ul></li></ul><h2 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h2><ol><li>存储容量：存储字数×字长。MDP位数反映存储字长</li><li>单位成本：每位价格&#x3D;总成本&#x2F;总容量。</li><li>存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</li></ol><blockquote><p>存取时间Ta：从启动一次存储操作到完成该操作的时间。分为读出时间和写入时间。<br>存取周期Tm：存储器进行一次完整的读写操作需要的时间，即连续两次独立访问存储器操作（读或写）之间的最小时间间隔。<br>主存宽带Rm：又称数据传输率， 每秒从主存上进出信息的最大数量。</p></blockquote><p><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3Ta%E5%92%8CTm.png"></p><hr><h1 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h1><ul><li>存储元：MOS管作为半导体元件，高电位通导，可给电容充电。由电容是否放电，表示0和1.</li><li>多个存储元合理连接，一排形成存储单元，由同一个输入线控制。多个存储单元构成存储体（存储矩阵）</li><li>译码器通过给予高低电位，使不同的存储单元输出至MDR中，再由CPU分析处理</li><li>注意读写控制线和片选线的数量。题目中考虑芯片所需的金属引脚。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3%E8%AF%91%E7%A0%81%E5%99%A81.png"><blockquote><p>存储芯片的描述：8×8，表示8K×8位，表示有8k个存储单元，每一个存储单元的存储字长是8位（每一行8个存储元）。<a href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8Ccpu%E7%9A%84%E9%93%BE%E6%8E%A5">与CPU的连接</a></p></blockquote></li><li>现代计算机，MDR、MAR常集成在CPU中，真正发挥寄存功能的并非上图的MAR、MDR，而是普通的寄存器。</li><li><strong>寻址</strong>：按字节寻址、按字寻址、按半字寻址、按双字寻址。</li></ul><h2 id="SRAM和DRAM（高频考点，二者的区别）"><a href="#SRAM和DRAM（高频考点，二者的区别）" class="headerlink" title="SRAM和DRAM（高频考点，二者的区别）"></a>SRAM和DRAM（高频考点，二者的区别）</h2><ul><li>DRAM:dynamic ，动态RAM，用于主存</li><li>SRAM:Static ，静态RAM，用于cache</li></ul><h3 id="存储元件不同导致的特征差异"><a href="#存储元件不同导致的特征差异" class="headerlink" title="存储元件不同导致的特征差异"></a>存储元件不同导致的特征差异</h3><ol><li><p><strong>DRAM</strong>，就是上文的<a href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">存储矩阵</a>构成的，使用栅极电容存储信息。</p><ul><li><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3RDAM%E8%8A%AF%E7%89%87.png"></li><li>电容放电信息被破坏，是破坏性读出，读后要有重写操作，也称<em>再生</em></li><li>成本低，集成度高，功耗低。</li><li>需要<a href="#DRAM%E7%9A%84%E5%88%B7%E6%96%B0">刷新</a>。</li><li>分两次送行列地址。</li></ul></li><li><p><strong>SRAM</strong>，使用双稳态触发器存储信息。</p><ul><li>存储元为双稳态触发器，如图：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3%E5%8F%8C%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8.png"></li><li>A高B低为1。A低B高为0。</li><li>读出数据后，触发器状态稳定，非破坏性读出，无需重写，<strong>因此读写速度更快</strong>。</li><li>成本高，集成度低，功耗大。</li><li>不需要刷新。</li><li>同时送行列地址。<blockquote><p>刷新：由于电容内电荷只能维持很短的时间，即使不断电，2ms后也会消失，因此要及时充电。</p></blockquote></li></ul></li></ol><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><ol><li>周期一般为2ms</li><li>每次刷新<strong>一行</strong>的存储单元。–存储单元排列成矩阵，行译码器和列译码器分别处理，这样可以<strong>使选通线变得更少。</strong><br>因为总数为n，本需要2^n条选通线。列成矩阵后，只需要2*2^（n&#x2F;2）条。</li><li>如何刷新？—有硬件支持，读出一行信息后重新写入，占用一个读&#x2F;写周期。</li><li>在何时刷新？<br><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%B7%E6%96%B0.png"></li></ol><h3 id="DRAM的地址复用技术"><a href="#DRAM的地址复用技术" class="headerlink" title="DRAM的地址复用技术"></a>DRAM的地址复用技术</h3><p>因为分两次送，即可以只采用一半的地址线，先送到行地址缓冲器，再将数据送到列地址缓冲器。</p><blockquote><p>地址线更少，芯片引脚更少。</p></blockquote><h2 id="只读存储器的ROM"><a href="#只读存储器的ROM" class="headerlink" title="只读存储器的ROM"></a>只读存储器的ROM</h2><p><strong>认识各种ROM：</strong><br><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3%E8%AE%A4%E8%AF%86rom.png"></p><ul><li><strong>计算机内的重要ROM</strong>：</li><li><strong>BIOS芯片</strong>：位于主板上，存储了“自举装入程序”，负责引导装入操作系统（开机）。</li><li><blockquote><p>逻辑上，BIOS也属于主存。</p></blockquote></li></ul><h2 id="双端口RAM和多模块存储器（408删除双端口RAM，不排除自命题）"><a href="#双端口RAM和多模块存储器（408删除双端口RAM，不排除自命题）" class="headerlink" title="双端口RAM和多模块存储器（408删除双端口RAM，不排除自命题）"></a>双端口RAM和多模块存储器（408删除双端口RAM，不排除自命题）</h2><h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><ul><li><p>多体并行存储器</p><blockquote><p>每一个模块都有相同的容量和存取速度。<br>各模块都是独立的，它们既能并行工作，又能交叉工作。 </p></blockquote></li><li><p>多体并行存储器分为高位和低位</p></li><li><p>区别在于存放地址信息的编码放置在前还是后。  </p></li><li><p>高位读取顺序直观表现为向下，低位向右，导致相同的连续访问顺序会使用不同的时间。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8.png">  </p></li><li><p>由上图知：低位交叉编址的多体并行存储器在<strong>处理连续情况</strong>下更有优势，宏观上，一个存储周期内，m体交叉存储器可以提供的数据量为单个模块的m倍，若存储周期为T,存取时间为r，为了不间断，应保证模块数m&gt;&#x3D;T&#x2F;r.<a href="https://www.bilibili.com/video/BV1ps4y1d73V?t=987.8&p=35">详细参考视频</a>。</p></li></ul><hr><h1 id="主存储器和CPU的链接"><a href="#主存储器和CPU的链接" class="headerlink" title="主存储器和CPU的链接"></a>主存储器和CPU的链接</h1><h2 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h2><p><a href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">单块存储芯片</a>中，片选信号CS&#x2F;CE,若有非标识，则为低电平有效，反之为高电平有效。<br>读写控制线用WE&#x2F;WR表示，低电平信号为写，高电平信号为读。（也可能分开，WE为读，OE为写）</p><ul><li>位扩展：A地址线通过控制总线传输连接。WE（write enable），通过控制总线连接。但D数据总线每次只能传输1bit， 因此多加芯片可以增加每次的处理位数。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/3/3%E4%BD%8D%E6%89%A9%E5%B1%951.png"></li></ul><h2 id="多块存储芯片与CPU的连接"><a href="#多块存储芯片与CPU的连接" class="headerlink" title="多块存储芯片与CPU的连接"></a>多块存储芯片与CPU的连接</h2><h3 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h3><h3 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法"></a>字扩展法</h3><h3 id="字位扩展法"><a href="#字位扩展法" class="headerlink" title="字位扩展法"></a>字位扩展法</h3><h2 id="关于译码器知识的补充"><a href="#关于译码器知识的补充" class="headerlink" title="关于译码器知识的补充"></a>关于译码器知识的补充</h2><hr><h1 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h1><h1 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h1><hr><h1 id="Cache的基本概念和原理"><a href="#Cache的基本概念和原理" class="headerlink" title="Cache的基本概念和原理"></a>Cache的基本概念和原理</h1><h2 id="Cache和主存的映射方式"><a href="#Cache和主存的映射方式" class="headerlink" title="Cache和主存的映射方式"></a>Cache和主存的映射方式</h2><h2 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h2><h2 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h2><hr><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理第二章-数据的表示和运算</title>
      <link href="/2023/07/21/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2023/07/21/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h1><blockquote><p>符号和其所在位置反映权重<br>十六进制：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</p></blockquote><h2 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h2><h3 id="二、八、十六转十"><a href="#二、八、十六转十" class="headerlink" title="二、八、十六转十"></a>二、八、十六转十</h3><ul><li>每一位的数 乘 位权，相加即可。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A21.png"></li></ul><h3 id="二、八、十六相互转化"><a href="#二、八、十六相互转化" class="headerlink" title="二、八、十六相互转化"></a>二、八、十六相互转化</h3><ul><li>二转八：从小数点开始往前每三位，转换成一个八进制数，小数点后每三位，转换成一个八进制数。不足三位，补0。  </li><li>二转十六同理：每四位转成一个16进制数。  </li><li>八转二、十六转二：将每一位数拆成相应的三位&#x2F;四位二进制数，最后组合即可。  </li><li>八转十六、十六转八：以二进制过度即可。</li></ul><h3 id="十转其它"><a href="#十转其它" class="headerlink" title="十转其它"></a>十转其它</h3><ul><li>将十进制化成二进制。  </li><li>分成整数和小数两部分处理。<br><strong>整数</strong>：除相应进制数，取余，最后逆取。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A23.png"><br><strong>小数</strong>：小数部分乘二，取整数部分（只为0&#x2F;1），小数部分再乘，直到小数部分为零。若出现循环，保留小数点后五位。正取。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A22.png"><blockquote><p>整数：除基取余</p><p>小数：乘基取整</p></blockquote></li></ul><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><blockquote><p>真值：实际的带正负号的数值。（人类习惯的样子）</p><p>机器数：把正负号数字化的数。（存到机器里）</p></blockquote><hr><h1 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h1><p>（新大纲已删除）</p><hr><h1 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h1><blockquote><p>无符号整数：自然数</p></blockquote><h2 id="无符号整数在计算机硬件内的表示"><a href="#无符号整数在计算机硬件内的表示" class="headerlink" title="无符号整数在计算机硬件内的表示"></a>无符号整数在计算机硬件内的表示</h2><ul><li>无符号整数位数由机器字长限制，会产生溢出。</li><li>全部二进制位全是数值， 没有符号位，第i位的位权是2^i-1。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B01.png"></li></ul><h2 id="无符号整数的加减法实现原理"><a href="#无符号整数的加减法实现原理" class="headerlink" title="无符号整数的加减法实现原理"></a>无符号整数的加减法实现原理</h2><ul><li><strong>加法</strong>：按位相加，向高位进位即可。</li><li><strong>减法</strong>： <ol><li>被减数不变  </li><li>减数全部位取反，末位加一后（从右向左找到第一个1，此1左边全部位取反）  </li><li>与被减数相加。</li></ol></li></ul><h1 id="带符号整数的表示和运算-原反补"><a href="#带符号整数的表示和运算-原反补" class="headerlink" title="带符号整数的表示和运算-原反补"></a>带符号整数的表示和运算-原反补</h1><blockquote><p>带符号整数：整数</p></blockquote><h2 id="带符号整数在计算机硬件中的表示"><a href="#带符号整数在计算机硬件中的表示" class="headerlink" title="带符号整数在计算机硬件中的表示"></a>带符号整数在计算机硬件中的表示</h2><ol><li>原码表示法：最高位作为符号位，0为正，1为负。其余位表示绝对值。<blockquote><p>缺点：不能使用正常加法（符号位）</p></blockquote></li><li>补码表示法：<br>   <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E5%8F%8D%E8%A1%A51.png"><blockquote><p>正数的原码，反码，补码都一致。</p><p>负数补码-原码的转换：从右往左，找到第一个1,1之前的所有非符号位取反。</p></blockquote></li></ol><h2 id="带符号整数的加减法运算"><a href="#带符号整数的加减法运算" class="headerlink" title="带符号整数的加减法运算"></a>带符号整数的加减法运算</h2><ul><li><strong>加法运算</strong>：直接用<a href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA">补码</a>进行计算  </li><li><strong>减法运算</strong>：A补-B补转换成A补+（-B补）<blockquote><p>将B补，从右往左找到第一个1，这个1左边的全部位取反，就是-B补。</p></blockquote><blockquote><p>至此，<strong>无符号整数的加减法</strong> 和 <strong>带符号整数补码加减法</strong> 运算过程相同，因此可以用同一套电路，节约成本.</p><p>在计算机内部，所有带符号整数加减法都转化成补码。</p></blockquote></li></ul><h2 id="原、反、补码的特性总结"><a href="#原、反、补码的特性总结" class="headerlink" title="原、反、补码的特性总结"></a>原、反、补码的特性总结</h2><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E5%8F%8D%E8%A1%A5%E6%80%BB%E7%BB%93.png"></p><hr><h1 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h1><p>补码的符号位取反，就是移码。<br>移码&#x3D;真值+偏置值。一般情况下，偏置值是2^（n-1），此时情况就如第一条。其它情况参考<a href="#IEEE745-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86">IEEE745</a><br>移码只用于表示整数。<br>移码可直观对比真值的大小。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%87%A0%E7%A7%8D%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%95%B4%E6%95%B0.png"></p><hr><h1 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h1><p>定点整数即带符号整数。<br>定点小数的小数点，默认隐藏在符号位后面。表示如图：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B01.png"><br>反码和补码的转换和定点整数一样。</p><p><strong>对比</strong>：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B02.png"></p><hr><h1 id="电路基本原理、加法器设计"><a href="#电路基本原理、加法器设计" class="headerlink" title="电路基本原理、加法器设计"></a>电路基本原理、加法器设计</h1><h2 id="算术逻辑单元作用原理"><a href="#算术逻辑单元作用原理" class="headerlink" title="算术逻辑单元作用原理"></a>算术逻辑单元作用原理</h2><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2ALU.png"></p><h2 id="电路基础知识"><a href="#电路基础知识" class="headerlink" title="电路基础知识"></a>电路基础知识</h2><p>基本逻辑运算：略</p><h2 id="加法器的实现"><a href="#加法器的实现" class="headerlink" title="加法器的实现"></a>加法器的实现</h2><p><strong>一位全加器</strong>：</p><ol><li>偶数个1，本位为0。奇数个1，本位为1。利用异或门实现。  </li><li>进位：出入中至少2个1.<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png"></li></ol><p><strong>串行加法器</strong>：</p><ul><li>只由一个全加器组成。</li></ul><p><strong>并行加法器</strong>：</p><ol><li>多个全加器串接</li><li>进位到前一个加法器，作为输入，逐级形成。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8.png"></li></ol><h1 id="并行进位加法器"><a href="#并行进位加法器" class="headerlink" title="并行进位加法器"></a>并行进位加法器</h1><p>（非重点）  </p><ol><li>由于表达式存在嵌套，展开后需要的信息都已知。  </li><li>此时，可以将已知的数据直接传递给前位，无需逐级等待。</li><li>速度更快。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png"></li></ol><h1 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h1><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E5%99%A81.png"></p><blockquote><ol><li>可以看到，进行加法运算时，直接输入Y信号，低位进位为0。</li><li>进行减法运算，多路选择器信号为1，会将Y全部取反，此时进位为1，相当于末位+1，得到-Y补，再进行加法。</li><li>此电路也可进行无符号整数的加减运算。但要注意<strong>溢出</strong>的判断逻辑。</li></ol></blockquote><h1 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h1><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%A0%87%E5%BF%97%E4%BD%8D1.png"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%A0%87%E5%BF%97%E4%BD%8D2.png"></p><blockquote><ol><li>有符号、无符号运算的<strong>溢出判断</strong>不一样，注意区分。</li><li>有符号，OF看<strong>最高位</strong>和<strong>次高位</strong>的<strong>进位</strong>，SF看<strong>最高位</strong></li><li>无符号，CF看<strong>最高位的进位</strong>和<strong>加减与否</strong></li></ol></blockquote><h1 id="定点数的移位计算"><a href="#定点数的移位计算" class="headerlink" title="定点数的移位计算"></a>定点数的移位计算</h1><h2 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h2><blockquote><p>移位：通过改变小数点的位置，来改变各数码位的位权。由此实现乘除法。</p></blockquote><ol><li>原码的算术移位：符号位不变，仅对数值位进行移位。<blockquote><p>右移，低位舍弃，高位补零。舍弃的低位是0，则相当于除2；若舍弃的不为0，则丢失精度。<br> 左移，同理，相当于乘2，舍弃最高位不为0，则出现严重误差。</p></blockquote></li><li>反码的算术移位： <blockquote><p>正数的处理和原码相同。<br> 负数移位时，高低位都补<strong>1</strong>.</p></blockquote></li><li>补码的算术移位：<blockquote><p>正数的处理和原码相同。<br> 负数移位时：右移，同反码，补1。左移，同原码，补0。</p></blockquote></li></ol><h2 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h2><p>逻辑移位：</p><blockquote><p>右移：高位补0，低位舍弃<br>左移：高位舍弃，低位补0</p></blockquote><p>应用:RGB表示。</p><h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><blockquote><p>即循环补位。简单说就是：12345–&gt;51234<br>带进位位的循环，相当于多了一个容器，一同参加循环。简单说就是：12345  6–&gt;61234  5。</p></blockquote><h1 id="原、补码的乘除法"><a href="#原、补码的乘除法" class="headerlink" title="原、补码的乘除法"></a>原、补码的乘除法</h1><h2 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h2><p>竖式和十进制乘法相同。<br>符号单独用异或处理，数值位取绝对值进行计算。<br>计算机实现：</p><blockquote><p>低位乘被乘数，放入ACC。<br>ACC和MQ统一右移，高位补0<br>ACC加下一波的低位、被乘数之积<br>循环进行，到符号位停止计算，注意小数点位置，得出结果。</p></blockquote><p><strong>如图</strong>：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%981.png" alt="开始"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%982.png" alt="低位乘被乘数，放入ACC"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%983.png" alt="ACC和MQ统一右移，高位补0"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%984.png" alt="ACC相加"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%985.png" alt="循环进行，最终结果"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%986.png" alt="例题"></p><h2 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h2><blockquote><ul><li>添加一个辅助位  </li><li>辅助位-MQ最低位&#x3D;1时，（ACC）+[x]补。</li><li>辅助位-MQ最低位&#x3D;0时，（ACC）+0。</li><li>辅助位-MQ最低位&#x3D;-1时，（ACC）+[-x]补。  </li><li>辅助位在MQ的最后面，初始为0。  </li><li>每次加法完成后，同样是算术右移。因为移位，辅助位变为上一次MQ最低位。  </li><li>被乘数采用双符号位补码，因为乘数MQ多了辅助位，被乘数也要多一位。  </li><li>补码乘法中，符号位也参与一次运算，即最后一次加法。</li></ul></blockquote><p>例题：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%A1%A5%E7%A0%81%E4%B9%981.png"></p><h2 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h2><ol><li><p>除法运算的思想<br> 类比十进制，每一步都是尽可能依靠除数拼凑出余数。处理时，可以共同乘2的次方来移动小数点，简化计算。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A41.png"></p></li><li><p>恢复余数法  </p><blockquote><ol><li>MQ初始默认全为0，ACC全0。</li><li>运算时，计算机默认最低位商（MQ）为1。</li><li>更新ACC内数据：现ACC为&#x3D;原ACC-MQ*除数</li><li>计算ACC若出错（余数为负），再更改商为0，并恢复余数(ACC)，不出错正常进行。</li><li>之后ACC和MQ都要算术<strong>左移</strong>一位,此时高位舍弃，低位补0。  </li><li>如此进行下去，直至MQ全部被替换，除法结束。<br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A42.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A43.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A44.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A45.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A46.png"><br>最后<br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A47.png"></li></ol></blockquote></li><li><p>加减交替法  </p><blockquote><p>是对恢复余数法的简化。<br>不再恢复余数，而是检测到余数为负时,直接全部左移，再加上下一个除数<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A48.png"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A49.png"></p></blockquote></li></ol><h2 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h2><p>也是加减交替法</p><ul><li>符号位也参与运算</li><li>被除数\余数、除数采用双符号位。</li><li>除数余数，同号商1，左移再减；异号商0，左移再加。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%A1%A5%E7%A0%81%E9%99%A41.png"></li></ul><hr><h1 id="C语言类型转换"><a href="#C语言类型转换" class="headerlink" title="C语言类型转换"></a>C语言类型转换</h1><ul><li>C语言中，定点整数都是用<strong>补码</strong>存储的</li><li>无符号与有符号数（short-unsigned short）：不改变数据内容，改变解释方式。</li><li>长整数变短整数（int-short，4-2）：高位截短，低位保留。</li><li>短整数变长整数（符号扩展）：有符号，负数补1，正数补0。无符号，高位补0即可。</li></ul><hr><h1 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h1><h2 id="大小端模式："><a href="#大小端模式：" class="headerlink" title="大小端模式："></a>大小端模式：</h2><ul><li>多字节数据在内存中的存储是连续的几个字节。</li><li>大端存储：最高有效字节为首，从低地址到高地址，依次往后。</li><li>小端存储：最低有效字节为首，从低地址到高地址，依次往后。</li></ul><h2 id="边界对齐："><a href="#边界对齐：" class="headerlink" title="边界对齐："></a>边界对齐：</h2><ul><li><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90.png"></li></ul><hr><h1 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h1><h2 id="浮点数的作用和基本原理"><a href="#浮点数的作用和基本原理" class="headerlink" title="浮点数的作用和基本原理"></a>浮点数的作用和基本原理</h2><ul><li>浮点数可以表示科学计数法，表示较大的数。包括阶码和尾数。</li><li>左边阶码表示指数，表示数值大小，常用补码或移码表示定点整数。</li><li>尾数相当于放在最前面，确定数字，数值的长度表示精度，常用原码和补码表示定点小数。</li><li>二进制中，阶码的底数通常为2。若出现4、8，代表2的相应次方。</li><li>尾数给出小数，阶码反映了小数点的移动距离。阶码正，点右移。</li><li>注意最前面一位常表示符号位。1.01101表示-0.01101，而不是-1.01101。</li></ul><h2 id="浮点数尾数的规格化"><a href="#浮点数尾数的规格化" class="headerlink" title="浮点数尾数的规格化"></a>浮点数尾数的规格化</h2><ul><li>尾数的最高位必须是有效值，即不能为0。否则会丧失精度</li></ul><ol><li><strong>左规</strong>： 两符号位相同，且最高数值位和符号位相同时，尾数连续左移，直到最高数值位和符号位的值不同为止。（111×××和000×××。111×××左移一位的结果为11×××0；000×××左移一位的结果为00×××0。）,最后阶码减去移动次数。</li><li><strong>右规</strong>： 两符号位不同，将尾数右移一位。 （01××××和10××××。01××××右移一位的结果为001×××；10××××右移一位的结果为110×××。）,最后阶码+1。</li><li><strong>舍去</strong>：对阶时，可能在尾数上增加一些值，最后需要舍去。如下两种方法：<ol><li><strong>0舍1入</strong>：看舍去的几位数，若最高位为1，则将舍去后的数末位+1。若最高位为0，直接舍去即可。</li><li><strong>置1</strong>：去掉多余的尾数，然后保证新尾数的最后一位为1（即是1不用管，是0改成1）即可。比如 Z&#x3D;00.11000111，置1法之后的结果为Z&#x3D;00.11001。</li></ol></li><li><strong>原码</strong>表示的尾数规格化：尾数最高位必须是1。<strong>补码</strong>表示的尾数规格化：尾数最高位和符号位符号相反。</li></ol><h1 id="IEEE745-浮点数标准"><a href="#IEEE745-浮点数标准" class="headerlink" title="IEEE745-浮点数标准"></a>IEEE745-浮点数标准</h1><p>阶码部分用移码表示。<br>此时移码的偏置值会根据类型改变。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2IEEE745.png"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2IEEE745-2.png"></p><h1 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h1><h2 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h2><ol><li><strong>对阶</strong>：将阶数对齐，一般将小阶转大阶。（因为计算机内部，尾数是定点小数）</li><li><strong>尾数加减</strong>：详见<a href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97">相关计算</a></li><li><strong>规格化</strong>：详见<a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96">规格化</a></li><li><strong>舍入</strong>：详见<a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96">舍去</a></li><li><strong>判断溢出</strong>：若规定阶码不能超过两位，运算后阶码查处范围，则溢出。（尾数溢出未必整体溢出，可通过3、4步补救。）</li><li><a href="https://www.bilibili.com/video/BV1ps4y1d73V?t=501.4&p=29">详细计算的精准空降</a></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul><li>部分在<a href="#C%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">C语言类型转换</a><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"></li></ul><h1 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h1><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%80%BB.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2023/07/19/hexo%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/07/19/hexo%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开始基于hexo和github搭建个人博客</p><blockquote><p>hexo上手简单，github免费</p></blockquote><h2 id="安装Node-js，git，"><a href="#安装Node-js，git，" class="headerlink" title="安装Node.js，git，"></a>安装Node.js，git，</h2><p>根据操作系统选择即可</p><blockquote><p><a href="https://nodejs.org/en">Node官网</a>, <a href="http://git.p2hp.com/">git官网</a>,</p></blockquote><h2 id="命令行操作，安装配置hexo"><a href="#命令行操作，安装配置hexo" class="headerlink" title="命令行操作，安装配置hexo"></a>命令行操作，安装配置hexo</h2><ol><li>创建文件夹，如hexo。进入文件夹，右键打开git bash</li><li>输入指令 <code>npm install -g hexo-cli</code>,即可在此文件夹中安装hexo</li><li>创建文件夹，如myblog。即在命令行中，输入 <code>hexo init myblog</code>，等待下载，会有如下文件：<ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul></li><li>测试博客，进入myblog这个文件夹，打开命令行，输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g   #让本体先运行一遍，做个检查</span><br><span class="line">hexo s   #开始hexo博客服务</span><br></pre></td></tr></table></figure></li><li>在浏览器中，输入 <code>localhost:4000</code>即可看到hexo博客的默认界面。（默认端口4000），ctrl+C可以关闭。</li></ol><h2 id="将博客部署到github"><a href="#将博客部署到github" class="headerlink" title="将博客部署到github"></a>将博客部署到github</h2><p>找到github中，你的个人仓库地址。在这个位置。复制链接<br><img src="/myimg/github仓库地址.png" alt="" width="400" height="300"></p><p>在命令行中，先设置你的github用户名和email</p><pre><code>git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;</code></pre><p>检查输入正确与否</p><pre><code>git config user.namegit config user.email</code></pre><p>进入博客配置文件 _config.yml，滑到最下方，找到 <code>deploy</code><br>更改如下：</p><pre><code>deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master</code></pre><p>安装部署插件：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>最后，在命令行中，依次输入：</p><pre><code>hexo cl #清除之前生成的东西，可以不加hexo g  hexo d  #进行部署</code></pre><p>网络可能影响部署情况，多加尝试。 若无报错，部署成功。<br>可以在你的github里，直接打开博客，无需利用git输入 <code>hexo s</code></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>可以进入hexo官网，挑选主题。<a href="https://hexo.io/themes/">主题链接</a><br>进入不同主题界面，有相应教程，按照步骤即可。</p>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo搭建 </tag>
            
            <tag> 教程 </tag>
            
            <tag> blog相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 语法初学习</title>
      <link href="/2023/07/19/md-study/"/>
      <url>/2023/07/19/md-study/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="markdown-语法初学习"><a href="#markdown-语法初学习" class="headerlink" title="markdown 语法初学习"></a>markdown 语法初学习</h1><hr><h2 id="字体："><a href="#字体：" class="headerlink" title="字体："></a>字体：</h2><p>正常</p><p><em>倾斜</em> <code>*倾斜*</code></p><p><em>倾斜</em> <code>—倾斜—</code></p><p><strong>加粗</strong> <code>**加粗**</code></p><p><em><strong>倾斜加粗</strong></em> <code>***倾斜加粗***</code></p><p><del>划线</del> <code>~~划线~~</code></p><hr><h2 id="网页链接："><a href="#网页链接：" class="headerlink" title="网页链接："></a>网页链接：</h2><p><a href="https://chunshan0.github.io/">https://chunshan0.github.io</a>&lt;括起来即可表示网站链接&gt;<br>或者<a href="https://chunshan0.github.io/">github链接</a>，采用格式： <code>[github链接](https://chunshan0.github.io)</code></p><hr><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><blockquote><p>文本前加&gt;即可引用</p></blockquote><blockquote><blockquote><p>多加&gt;&gt;即可嵌套引用，引用中可使用其它md语法</p><blockquote><p>like this</p></blockquote></blockquote></blockquote><hr><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><ul><li>加*，+，—可表示无序列表，注意其后加空格</li></ul><ol><li>直接</li><li>数字</li><li>或字母</li><li>是有序列表，可使用其它语法</li></ol><hr><h2 id="流程图、时序图等"><a href="#流程图、时序图等" class="headerlink" title="流程图、时序图等"></a>流程图、时序图等</h2><p>需要使用外置标签mermaid<br>写法：  </p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">內容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">pie</span><br><span class="line">title Key elements in Product X</span><br><span class="line">&quot;Calcium&quot; : 42.96</span><br><span class="line">&quot;Potassium&quot; : 50.05</span><br><span class="line">&quot;Magnesium&quot; : 10.01</span><br><span class="line">&quot;Iron&quot; :  5</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  pietitle Key elements in Product X&quot;Calcium&quot; : 42.96&quot;Potassium&quot; : 50.05&quot;Magnesium&quot; : 10.01&quot;Iron&quot; :  5  </pre></div><hr><h2 id="嵌入代码："><a href="#嵌入代码：" class="headerlink" title="嵌入代码："></a>嵌入代码：</h2><p>插入代码 <code>like this</code>,使用&#96;包括，或者TAB缩进</p><pre><code>like this</code></pre><p>或是使用格式（括号省去）：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">(<span class="code">```代码形式    内容可被渲染```</span>)</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">内容可被渲染</span><br></pre></td></tr></table></figure><hr><h2 id="插入图片："><a href="#插入图片：" class="headerlink" title="插入图片："></a>插入图片：</h2><p>插入图片的格式如下<code>![描述](图片地址)</code></p><hr><h2 id="锚点："><a href="#锚点：" class="headerlink" title="锚点："></a>锚点：</h2><p>锚点：<br>锚点其实就是页内超链接。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。<br>比如：<a href="#%E9%94%9A%E7%82%B9">锚点</a></p><hr><h2 id="注脚："><a href="#注脚：" class="headerlink" title="注脚："></a>注脚：</h2><p>注脚<a href="111">^1</a>也可实现业内跳转</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog相关 </tag>
            
            <tag> 语法 </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临行碎碎念</title>
      <link href="/2023/06/30/%E4%B8%B4%E8%A1%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2023/06/30/%E4%B8%B4%E8%A1%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间总推着我们向前，自由的思考总是求而不得。<br>或迫于第二天的早车，而在能够反思的深夜劝自己尽快入睡；或在意识徜徉的午后，想起避而不及的任务而兴致全无。<br>成长，就像注定会踏上一个无形的列车，到达下一站前，下不来。<br>这种自我意愿与生活的割裂感愈发清晰，需要找到合适的平衡点了。也就是，要努力与生活和解吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
