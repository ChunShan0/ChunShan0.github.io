<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理第二章-数据的表示和运算</title>
      <link href="/2023/07/21/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2023/07/21/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h1><blockquote><p>符号和其所在位置反映权重<br>十六进制：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</p></blockquote><h2 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h2><h3 id="二、八、十六转十"><a href="#二、八、十六转十" class="headerlink" title="二、八、十六转十"></a>二、八、十六转十</h3><ul><li>每一位的数 乘 位权，相加即可。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A21.png"></li></ul><h3 id="二、八、十六相互转化"><a href="#二、八、十六相互转化" class="headerlink" title="二、八、十六相互转化"></a>二、八、十六相互转化</h3><ul><li>二转八：从小数点开始往前每三位，转换成一个八进制数，小数点后每三位，转换成一个八进制数。不足三位，补0。  </li><li>二转十六同理：每四位转成一个16进制数。  </li><li>八转二、十六转二：将每一位数拆成相应的三位&#x2F;四位二进制数，最后组合即可。  </li><li>八转十六、十六转八：以二进制过度即可。</li></ul><h3 id="十转其它"><a href="#十转其它" class="headerlink" title="十转其它"></a>十转其它</h3><ul><li>将十进制化成二进制。  </li><li>分成整数和小数两部分处理。<br><strong>整数</strong>：除相应进制数，取余，最后逆取。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A23.png"><br><strong>小数</strong>：小数部分乘二，取整数部分（只为0&#x2F;1），小数部分再乘，直到小数部分为零。若出现循环，保留小数点后五位。正取。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A22.png"><blockquote><p>整数：除基取余</p><p>小数：乘基取整</p></blockquote></li></ul><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><blockquote><p>真值：实际的带正负号的数值。（人类习惯的样子）</p><p>机器数：把正负号数字化的数。（存到机器里）</p></blockquote><hr><h1 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h1><p>（新大纲已删除）</p><hr><h1 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h1><blockquote><p>无符号整数：自然数</p></blockquote><h2 id="无符号整数在计算机硬件内的表示"><a href="#无符号整数在计算机硬件内的表示" class="headerlink" title="无符号整数在计算机硬件内的表示"></a>无符号整数在计算机硬件内的表示</h2><ul><li>无符号整数位数由机器字长限制，会产生溢出。</li><li>全部二进制位全是数值， 没有符号位，第i位的位权是2^i-1。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B01.png"></li></ul><h2 id="无符号整数的加减法实现原理"><a href="#无符号整数的加减法实现原理" class="headerlink" title="无符号整数的加减法实现原理"></a>无符号整数的加减法实现原理</h2><ul><li><strong>加法</strong>：按位相加，向高位进位即可。</li><li><strong>减法</strong>： <ol><li>被减数不变  </li><li>减数全部位取反，末位加一后（从右向左找到第一个1，此1左边全部位取反）  </li><li>与被减数相加。</li></ol></li></ul><h1 id="带符号整数的表示和运算-原反补"><a href="#带符号整数的表示和运算-原反补" class="headerlink" title="带符号整数的表示和运算-原反补"></a>带符号整数的表示和运算-原反补</h1><blockquote><p>带符号整数：整数</p></blockquote><h2 id="带符号整数在计算机硬件中的表示"><a href="#带符号整数在计算机硬件中的表示" class="headerlink" title="带符号整数在计算机硬件中的表示"></a>带符号整数在计算机硬件中的表示</h2><ol><li>原码表示法：最高位作为符号位，0为正，1为负。其余位表示绝对值。<blockquote><p>缺点：不能使用正常加法（符号位）</p></blockquote></li><li>补码表示法：<br>   <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E5%8F%8D%E8%A1%A51.png"><blockquote><p>正数的原码，反码，补码都一致。</p><p>负数补码-原码的转换：从右往左，找到第一个1,1之前的所有非符号位取反。</p></blockquote></li></ol><h2 id="带符号整数的加减法运算"><a href="#带符号整数的加减法运算" class="headerlink" title="带符号整数的加减法运算"></a>带符号整数的加减法运算</h2><ul><li><strong>加法运算</strong>：直接用<a href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA">补码</a>进行计算  </li><li><strong>减法运算</strong>：A补-B补转换成A补+（-B补）<blockquote><p>将B补，从右往左找到第一个1，这个1左边的全部位取反，就是-B补。</p></blockquote><blockquote><p>至此，<strong>无符号整数的加减法</strong> 和 <strong>带符号整数补码加减法</strong> 运算过程相同，因此可以用同一套电路，节约成本.</p><p>在计算机内部，所有带符号整数加减法都转化成补码。</p></blockquote></li></ul><h2 id="原、反、补码的特性总结"><a href="#原、反、补码的特性总结" class="headerlink" title="原、反、补码的特性总结"></a>原、反、补码的特性总结</h2><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E5%8F%8D%E8%A1%A5%E6%80%BB%E7%BB%93.png"></p><hr><h1 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h1><p>补码的符号位取反，就是移码。<br>移码&#x3D;真值+偏置值。一般情况下，偏置值是2^（n-1），此时情况就如第一条。其它情况参考<a href="#IEEE745-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86">IEEE745</a><br>移码只用于表示整数。<br>移码可直观对比真值的大小。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%87%A0%E7%A7%8D%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%95%B4%E6%95%B0.png"></p><hr><h1 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h1><p>定点整数即带符号整数。<br>定点小数的小数点，默认隐藏在符号位后面。表示如图：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B01.png"><br>反码和补码的转换和定点整数一样。</p><p><strong>对比</strong>：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B02.png"></p><hr><h1 id="电路基本原理、加法器设计"><a href="#电路基本原理、加法器设计" class="headerlink" title="电路基本原理、加法器设计"></a>电路基本原理、加法器设计</h1><h2 id="算术逻辑单元作用原理"><a href="#算术逻辑单元作用原理" class="headerlink" title="算术逻辑单元作用原理"></a>算术逻辑单元作用原理</h2><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2ALU.png"></p><h2 id="电路基础知识"><a href="#电路基础知识" class="headerlink" title="电路基础知识"></a>电路基础知识</h2><p>基本逻辑运算：略</p><h2 id="加法器的实现"><a href="#加法器的实现" class="headerlink" title="加法器的实现"></a>加法器的实现</h2><p><strong>一位全加器</strong>：</p><ol><li>偶数个1，本位为0。奇数个1，本位为1。利用异或门实现。  </li><li>进位：出入中至少2个1.<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png"></li></ol><p><strong>串行加法器</strong>：</p><ul><li>只由一个全加器组成。</li></ul><p><strong>并行加法器</strong>：</p><ol><li>多个全加器串接</li><li>进位到前一个加法器，作为输入，逐级形成。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8.png"></li></ol><h1 id="并行进位加法器"><a href="#并行进位加法器" class="headerlink" title="并行进位加法器"></a>并行进位加法器</h1><p>（非重点）  </p><ol><li>由于表达式存在嵌套，展开后需要的信息都已知。  </li><li>此时，可以将已知的数据直接传递给前位，无需逐级等待。</li><li>速度更快。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png"></li></ol><h1 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h1><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E5%99%A81.png"></p><blockquote><ol><li>可以看到，进行加法运算时，直接输入Y信号，低位进位为0。</li><li>进行减法运算，多路选择器信号为1，会将Y全部取反，此时进位为1，相当于末位+1，得到-Y补，再进行加法。</li><li>此电路也可进行无符号整数的加减运算。但要注意<strong>溢出</strong>的判断逻辑。</li></ol></blockquote><h1 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h1><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%A0%87%E5%BF%97%E4%BD%8D1.png"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%A0%87%E5%BF%97%E4%BD%8D2.png"></p><blockquote><ol><li>有符号、无符号运算的<strong>溢出判断</strong>不一样，注意区分。</li><li>有符号，OF看<strong>最高位</strong>和<strong>次高位</strong>的<strong>进位</strong>，SF看<strong>最高位</strong></li><li>无符号，CF看<strong>最高位的进位</strong>和<strong>加减与否</strong></li></ol></blockquote><h1 id="定点数的移位计算"><a href="#定点数的移位计算" class="headerlink" title="定点数的移位计算"></a>定点数的移位计算</h1><h2 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h2><blockquote><p>移位：通过改变小数点的位置，来改变各数码位的位权。由此实现乘除法。</p></blockquote><ol><li>原码的算术移位：符号位不变，仅对数值位进行移位。<blockquote><p>右移，低位舍弃，高位补零。舍弃的低位是0，则相当于除2；若舍弃的不为0，则丢失精度。<br> 左移，同理，相当于乘2，舍弃最高位不为0，则出现严重误差。</p></blockquote></li><li>反码的算术移位： <blockquote><p>正数的处理和原码相同。<br> 负数移位时，高低位都补<strong>1</strong>.</p></blockquote></li><li>补码的算术移位：<blockquote><p>正数的处理和原码相同。<br> 负数移位时：右移，同反码，补1。左移，同原码，补0。</p></blockquote></li></ol><h2 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h2><p>逻辑移位：</p><blockquote><p>右移：高位补0，低位舍弃<br>左移：高位舍弃，低位补0</p></blockquote><p>应用:RGB表示。</p><h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><blockquote><p>即循环补位。简单说就是：12345–&gt;51234<br>带进位位的循环，相当于多了一个容器，一同参加循环。简单说就是：12345  6–&gt;61234  5。</p></blockquote><h1 id="原、补码的乘除法"><a href="#原、补码的乘除法" class="headerlink" title="原、补码的乘除法"></a>原、补码的乘除法</h1><h2 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h2><p>竖式和十进制乘法相同。<br>符号单独用异或处理，数值位取绝对值进行计算。<br>计算机实现：</p><blockquote><p>低位乘被乘数，放入ACC。<br>ACC和MQ统一右移，高位补0<br>ACC加下一波的低位、被乘数之积<br>循环进行，到符号位停止计算，注意小数点位置，得出结果。</p></blockquote><p><strong>如图</strong>：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%981.png" alt="开始"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%982.png" alt="低位乘被乘数，放入ACC"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%983.png" alt="ACC和MQ统一右移，高位补0"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%984.png" alt="ACC相加"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%985.png" alt="循环进行，最终结果"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E4%B9%986.png" alt="例题"></p><h2 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h2><blockquote><ul><li>添加一个辅助位  </li><li>辅助位-MQ最低位&#x3D;1时，（ACC）+[x]补。</li><li>辅助位-MQ最低位&#x3D;0时，（ACC）+0。</li><li>辅助位-MQ最低位&#x3D;-1时，（ACC）+[-x]补。  </li><li>辅助位在MQ的最后面，初始为0。  </li><li>每次加法完成后，同样是算术右移。因为移位，辅助位变为上一次MQ最低位。  </li><li>被乘数采用双符号位补码，因为乘数MQ多了辅助位，被乘数也要多一位。  </li><li>补码乘法中，符号位也参与一次运算，即最后一次加法。</li></ul></blockquote><p>例题：<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%A1%A5%E7%A0%81%E4%B9%981.png"></p><h2 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h2><ol><li><p>除法运算的思想<br> 类比十进制，每一步都是尽可能依靠除数拼凑出余数。处理时，可以共同乘2的次方来移动小数点，简化计算。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A41.png"></p></li><li><p>恢复余数法  </p><blockquote><ol><li>MQ初始默认全为0，ACC全0。</li><li>运算时，计算机默认最低位商（MQ）为1。</li><li>更新ACC内数据：现ACC为&#x3D;原ACC-MQ*除数</li><li>计算ACC若出错（余数为负），再更改商为0，并恢复余数(ACC)，不出错正常进行。</li><li>之后ACC和MQ都要算术<strong>左移</strong>一位,此时高位舍弃，低位补0。  </li><li>如此进行下去，直至MQ全部被替换，除法结束。<br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A42.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A43.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A44.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A45.png"><br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A46.png"><br>最后<br> <img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A47.png"></li></ol></blockquote></li><li><p>加减交替法  </p><blockquote><p>是对恢复余数法的简化。<br>不再恢复余数，而是检测到余数为负时,直接全部左移，再加上下一个除数<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A48.png"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E5%8E%9F%E7%A0%81%E9%99%A49.png"></p></blockquote></li></ol><h2 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h2><p>也是加减交替法</p><ul><li>符号位也参与运算</li><li>被除数\余数、除数采用双符号位。</li><li>除数余数，同号商1，左移再减；异号商0，左移再加。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%A1%A5%E7%A0%81%E9%99%A41.png"></li></ul><hr><h1 id="C语言类型转换"><a href="#C语言类型转换" class="headerlink" title="C语言类型转换"></a>C语言类型转换</h1><ul><li>C语言中，定点整数都是用<strong>补码</strong>存储的</li><li>无符号与有符号数（short-unsigned short）：不改变数据内容，改变解释方式。</li><li>长整数变短整数（int-short，4-2）：高位截短，低位保留。</li><li>短整数变长整数（符号扩展）：有符号，负数补1，正数补0。无符号，高位补0即可。</li></ul><hr><h1 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h1><h2 id="大小端模式："><a href="#大小端模式：" class="headerlink" title="大小端模式："></a>大小端模式：</h2><ul><li>多字节数据在内存中的存储是连续的几个字节。</li><li>大端存储：最高有效字节为首，从低地址到高地址，依次往后。</li><li>小端存储：最低有效字节为首，从低地址到高地址，依次往后。</li></ul><h2 id="边界对齐："><a href="#边界对齐：" class="headerlink" title="边界对齐："></a>边界对齐：</h2><ul><li><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90.png"></li></ul><hr><h1 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h1><h2 id="浮点数的作用和基本原理"><a href="#浮点数的作用和基本原理" class="headerlink" title="浮点数的作用和基本原理"></a>浮点数的作用和基本原理</h2><ul><li>浮点数可以表示科学计数法，表示较大的数。包括阶码和尾数。</li><li>左边阶码表示指数，表示数值大小，常用补码或移码表示定点整数。</li><li>尾数相当于放在最前面，确定数字，数值的长度表示精度，常用原码和补码表示定点小数。</li><li>二进制中，阶码的底数通常为2。若出现4、8，代表2的相应次方。</li><li>尾数给出小数，阶码反映了小数点的移动距离。阶码正，点右移。</li><li>注意最前面一位常表示符号位。1.01101表示-0.01101，而不是-1.01101。</li></ul><h2 id="浮点数尾数的规格化"><a href="#浮点数尾数的规格化" class="headerlink" title="浮点数尾数的规格化"></a>浮点数尾数的规格化</h2><ul><li>尾数的最高位必须是有效值，即不能为0。否则会丧失精度</li></ul><ol><li><strong>左规</strong>： 两符号位相同，且最高数值位和符号位相同时，尾数连续左移，直到最高数值位和符号位的值不同为止。（111×××和000×××。111×××左移一位的结果为11×××0；000×××左移一位的结果为00×××0。）,最后阶码减去移动次数。</li><li><strong>右规</strong>： 两符号位不同，将尾数右移一位。 （01××××和10××××。01××××右移一位的结果为001×××；10××××右移一位的结果为110×××。）,最后阶码+1。</li><li><strong>舍去</strong>：对阶时，可能在尾数上增加一些值，最后需要舍去。如下两种方法：<ol><li><strong>0舍1入</strong>：看舍去的几位数，若最高位为1，则将舍去后的数末位+1。若最高位为0，直接舍去即可。</li><li><strong>置1</strong>：去掉多余的尾数，然后保证新尾数的最后一位为1（即是1不用管，是0改成1）即可。比如 Z&#x3D;00.11000111，置1法之后的结果为Z&#x3D;00.11001。</li></ol></li><li><strong>原码</strong>表示的尾数规格化：尾数最高位必须是1。<strong>补码</strong>表示的尾数规格化：尾数最高位和符号位符号相反。</li></ol><h1 id="IEEE745-浮点数标准"><a href="#IEEE745-浮点数标准" class="headerlink" title="IEEE745-浮点数标准"></a>IEEE745-浮点数标准</h1><p>阶码部分用移码表示。<br>此时移码的偏置值会根据类型改变。<br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2IEEE745.png"><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2IEEE745-2.png"></p><h1 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h1><h2 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h2><ol><li><strong>对阶</strong>：将阶数对齐，一般将小阶转大阶。（因为计算机内部，尾数是定点小数）</li><li><strong>尾数加减</strong>：详见<a href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97">相关计算</a></li><li><strong>规格化</strong>：详见<a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96">规格化</a></li><li><strong>舍入</strong>：详见<a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96">舍去</a></li><li><strong>判断溢出</strong>：若规定阶码不能超过两位，运算后阶码查处范围，则溢出。（尾数溢出未必整体溢出，可通过3、4步补救。）</li><li><a href="https://www.bilibili.com/video/BV1ps4y1d73V?t=501.4&p=29">详细计算的精准空降</a></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul><li>部分在<a href="#C%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">C语言类型转换</a><br><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"></li></ul><h1 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h1><p><img src="/myimg/%E8%AE%A1%E7%BB%84/2/2%E6%80%BB.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2023/07/19/hexo%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/07/19/hexo%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>开始基于hexo和github搭建个人博客</p><blockquote><p>hexo上手简单，github免费</p></blockquote><h2 id="安装Node-js，git，"><a href="#安装Node-js，git，" class="headerlink" title="安装Node.js，git，"></a>安装Node.js，git，</h2><p>根据操作系统选择即可</p><blockquote><p><a href="https://nodejs.org/en">Node官网</a>, <a href="http://git.p2hp.com/">git官网</a>,</p></blockquote><h2 id="命令行操作，安装配置hexo"><a href="#命令行操作，安装配置hexo" class="headerlink" title="命令行操作，安装配置hexo"></a>命令行操作，安装配置hexo</h2><ol><li>创建文件夹，如hexo。进入文件夹，右键打开git bash</li><li>输入指令 <code>npm install -g hexo-cli</code>,即可在此文件夹中安装hexo</li><li>创建文件夹，如myblog。即在命令行中，输入 <code>hexo init myblog</code>，等待下载，会有如下文件：<ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul></li><li>测试博客，进入myblog这个文件夹，打开命令行，输入 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   #让本体先运行一遍，做个检查</span><br><span class="line">hexo s   #开始hexo博客服务</span><br></pre></td></tr></table></figure></li><li>在浏览器中，输入 <code>localhost:4000</code>即可看到hexo博客的默认界面。（默认端口4000），ctrl+C可以关闭。</li></ol><h2 id="将博客部署到github"><a href="#将博客部署到github" class="headerlink" title="将博客部署到github"></a>将博客部署到github</h2><p>找到github中，你的个人仓库地址。在这个位置。复制链接<br><img src="/myimg/github仓库地址.png" alt="" width="400" height="300"></p><p>在命令行中，先设置你的github用户名和email</p><pre><code>git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;</code></pre><p>检查输入正确与否</p><pre><code>git config user.namegit config user.email</code></pre><p>进入博客配置文件 _config.yml，滑到最下方，找到 <code>deploy</code><br>更改如下：</p><pre><code>deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master</code></pre><p>安装部署插件：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>最后，在命令行中，依次输入：</p><pre><code>hexo cl #清除之前生成的东西，可以不加hexo g  hexo d  #进行部署</code></pre><p>网络可能影响部署情况，多加尝试。 若无报错，部署成功。<br>可以在你的github里，直接打开博客，无需利用git输入 <code>hexo s</code></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>可以进入hexo官网，挑选主题。<a href="https://hexo.io/themes/">主题链接</a><br>进入不同主题界面，有相应教程，按照步骤即可。</p>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo搭建 </tag>
            
            <tag> 教程 </tag>
            
            <tag> blog相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 语法初学习</title>
      <link href="/2023/07/19/md-study/"/>
      <url>/2023/07/19/md-study/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown-语法初学习"><a href="#markdown-语法初学习" class="headerlink" title="markdown 语法初学习"></a>markdown 语法初学习</h1><hr><h2 id="字体："><a href="#字体：" class="headerlink" title="字体："></a>字体：</h2><p>正常</p><p><em>倾斜</em> <code>*倾斜*</code></p><p><em>倾斜</em> <code>—倾斜—</code></p><p><strong>加粗</strong> <code>**加粗**</code></p><p><em><strong>倾斜加粗</strong></em> <code>***倾斜加粗***</code></p><p><del>划线</del> <code>~~划线~~</code></p><hr><h2 id="网页链接："><a href="#网页链接：" class="headerlink" title="网页链接："></a>网页链接：</h2><p><a href="https://chunshan0.github.io/">https://chunshan0.github.io</a>&lt;括起来即可表示网站链接&gt;<br>或者<a href="https://chunshan0.github.io/">github链接</a>，采用格式： <code>[github链接](https://chunshan0.github.io)</code></p><hr><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><blockquote><p>文本前加&gt;即可引用</p></blockquote><blockquote><blockquote><p>多加&gt;&gt;即可嵌套引用，引用中可使用其它md语法</p><blockquote><p>like this</p></blockquote></blockquote></blockquote><hr><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><ul><li>加*，+，—可表示无序列表，注意其后加空格</li></ul><ol><li>直接</li><li>数字</li><li>或字母</li><li>是有序列表，可使用其它语法</li></ol><hr><h2 id="流程图-暂不清楚"><a href="#流程图-暂不清楚" class="headerlink" title="流程图(暂不清楚)"></a>流程图(暂不清楚)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><hr><h2 id="嵌入代码："><a href="#嵌入代码：" class="headerlink" title="嵌入代码："></a>嵌入代码：</h2><p>插入代码 <code>like this</code>,使用&#96;包括，或者TAB缩进</p><pre><code>like this</code></pre><hr><h2 id="插入图片："><a href="#插入图片：" class="headerlink" title="插入图片："></a>插入图片：</h2><p>插入图片的格式如下<code>![描述](图片地址)</code></p><hr><h2 id="锚点："><a href="#锚点：" class="headerlink" title="锚点："></a>锚点：</h2><p>锚点：<br>锚点其实就是页内超链接。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。<br>比如：<a href="#%E9%94%9A%E7%82%B9">锚点</a></p><hr><h2 id="注脚："><a href="#注脚：" class="headerlink" title="注脚："></a>注脚：</h2><p>注脚<a href="111">^1</a>也可实现业内跳转</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> markdown </tag>
            
            <tag> blog相关 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
